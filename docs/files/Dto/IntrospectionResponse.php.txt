<?php
//
// Copyright (C) 2018-2020 Authlete, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied. See the License for the specific
// language governing permissions and limitations under the
// License.
//


/**
 * File containing the definition of IntrospectionResponse class.
 */


namespace Authlete\Dto;


use Authlete\Util\LanguageUtility;
use Authlete\Util\ValidationUtility;


/**
 * Response from Authlete's /api/auth/introspection API.
 *
 * Authlete's `/api/auth/introspection` API returns JSON which can be mapped
 * to this class. The resource server should retrieve the value of the
 * `action` response parameter from the response and take the following steps
 * according to the value.
 *
 * When the value returned from `getAction()` method is
 * `IntrospectionAction::$INTERNAL_SERVER_ERROR`, it means that the request
 * from the resource server was wrong or that an error occurred in Authlete.
 * In either case, from a viewpoint of the client application, it is an error
 * on the server side. Therefore, the resource server should generate a
 * response to the client application with the HTTP status of
 * `500 Internal Server Error`.
 *
 * In this case, `getResponseContent()` method returns a string which
 * describes the error in the format of
 * [RFC 6750](https://tools.ietf.org/html/rfc6750) (OAuth 2.0 Bearer Token
 * Usage), so if the protected resource of the resource server wants to
 * return an error response to the client application in the way that
 * complies with RFC 6750, the string returned from `getResponseContent()`
 * method can be used as the value of the `WWW-Authenticate` header. The
 * following is an example response which complies with RFC 6750.
 *
 * ```
 * HTTP/1.1 500 Internal Server Error
 * WWW-Authenticate: (The value returned from getResponseContent())
 * Cache-Control: no-store
 * Pragma: no-cache
 * ```
 *
 * When the value returned from `getAction()` method is
 * `IntrospectionAction::$BAD_REQUEST`, it means that the request from the
 * client application does not contain an access token (= the request from
 * the resource server to Authlete does not contain the `token` request
 * parameter).
 *
 * In this case, `getResponseContent()` method returns a string which
 * describes the error in the format of
 * [RFC 6750](https://tools.ietf.org/html/rfc6750) (OAuth 2.0 Bearer Token
 * Usage), so if the protected resource of the resource server wants to
 * return an error response to the client application in the way that
 * complies with RFC 6750, the string returned from `getResponseContent()`
 * method can be used as the value of the `WWW-Authenticate` header. The
 * following is an example response which complies with RFC 6750.
 *
 * ```
 * HTTP/1.1 400 Bad Request
 * WWW-Authenticate: (The value returned from getResponseContent())
 * Cache-Control: no-store
 * Pragma: no-cache
 * ```
 *
 * When the value returned from `getAction()` method is
 * `IntrospectionAction::$UNAUTHORIZED`, it means that the access token does
 * not exist or has expired. Or the client application associated with the
 * access token does not exist any longer.
 *
 * In this case, `getResponseContent()` method returns a string which
 * describes the error in the format of
 * [RFC 6750](https://tools.ietf.org/html/rfc6750) (OAuth 2.0 Bearer Token
 * Usage), so if the protected resource of the resource server wants to
 * return an error response to the client application in the way that
 * complies with RFC 6750, the string returned from `getResponseContent()`
 * method can be used as the value of the `WWW-Authenticate` header. The
 * following is an example response which complies with RFC 6750.
 *
 * ```
 * HTTP/1.1 401 Unauthorized
 * WWW-Authenticate: (The value returned from getResponseContent())
 * Cache-Control: no-store
 * Pragma: no-cache
 * ```
 *
 * When the value returned from `getAction()` method is
 * `IntrospectionAction::$FORBIDDEN`, it means that the access token does
 * not cover the required scopes or that the subject associated with the
 * access token is different from the subject specified by the API call.
 *
 * In this case, `getResponseContent()` method returns a string which
 * describes the error in the format of
 * [RFC 6750](https://tools.ietf.org/html/rfc6750) (OAuth 2.0 Bearer Token
 * Usage), so if the protected resource of the resource server wants to
 * return an error response to the client application in the way that
 * complies with RFC 6750, the string returned from `getResponseContent()`
 * method can be used as the value of the `WWW-Authenticate` header. The
 * following is an example response which complies with RFC 6750.
 *
 * ```
 * HTTP/1.1 403 Forbidden
 * WWW-Authenticate: (The value returned from getResponseContent())
 * Cache-Control: no-store
 * Pragma: no-cache
 * ```
 *
 * When the value returned from `getAction()` method is
 * `IntrospectionAction::$OK`, it means that the access token which the
 * client application presented is valid (= exists and has not expired).
 * The resource server is supposed to return the proteced resource to the
 * client application.
 *
 * In this case, `getResponseContent()` property returns
 * `Bearer error=\"invalid_request\""`. This is the simplest string which
 * can be used as the value of the `WWW-Authenticate` header to indicate
 * `400 Bad Request`. The resource server may use this string to tell the
 * client application that the request was bad. But in such a case, if
 * possible, the resource server should generate a more informative error
 * message to help developers of client applications. The following is an
 * example error response which complies with RFC 6750.
 *
 * ```
 * HTTP/1.1 400 Bad Request
 * WWW-Authenticate: (The value returned from getResponseContent())
 * Cache-Control: no-store
 * Pragma: no-cache
 * ```
 *
 * Basically, `getResponseContent()` method returns a string which describes
 * the error in the format of
 * [RFC 6750](https://tools.ietf.org/html/rfc6750") (OAuth 2.0 Bearer Token
 * Usage), so if the resource server has selected `Bearer` as the token type,
 * the string returned from `getResponseContent()` method can be used directly
 * as the value for the `WWW-Authenticate` header. However, if the service has
 * selected another different token type, the resource server has to generate
 * error message for itself.
 */
class IntrospectionResponse extends ApiResponse
{
    private $action                = null;  // \Authlete\Dto\IntrospectionAction
    private $clientId              = null;  // string or (64-bit) integer
    private $subject               = null;  // string
    private $scopes                = null;  // array of string
    private $existent              = false; // boolean
    private $usable                = false; // boolean
    private $sufficient            = false; // boolean
    private $refreshable           = false; // boolean
    private $responseContent       = null;  // string
    private $expiresAt             = null;  // string or (64-bit) integer
    private $properties            = null;  // array of \Authlete\Dto\Property
    private $clientIdAlias         = null;  // string
    private $clientIdAliasUsed     = false; // boolean
    private $certificateThumbprint = null;  // string
    private $resources             = null;  // array of string
    private $accessTokenResources  = null;  // array of string


    /**
     * Get the next action that the resource server should take.
     *
     * @return IntrospectionAction
     *     The next action that the resource server should take.
     */
    public function getAction()
    {
        return $this->action;
    }


    /**
     * Set the next action that the resource server should take.
     *
     * @param IntrospectionAction $action
     *     The next action that the resource server should take.
     *
     * @return IntrospectionAction
     *     `$this` object.
     */
    public function setAction(IntrospectionAction $action = null)
    {
        $this->action = $action;

        return $this;
    }


    /**
     * Get the client ID of the client application to which the access token
     * has been issued.
     *
     * @return integer|string
     *     The ID of the client application associated with the access token.
     */
    public function getClientId()
    {
        return $this->clientId;
    }


    /**
     * Set the client ID of the client application to which the access token
     * has been issued.
     *
     * @param integer|string $clientId
     *     The ID of the client application associated with the access token.
     *
     * @return IntrospectionAction
     *     `$this` object.
     */
    public function setClientId($clientId)
    {
        ValidationUtility::ensureNullOrStringOrInteger('$clientId', $clientId);

        $this->clientId = $clientId;

        return $this;
    }


    /**
     * Get the subject (= unique identifier) of the end-user (= resource owner)
     * who allowed the authorization server  to issue the access token to the
     * client application.
     *
     * @return string
     *     The subject of the end-user associated with the access token.
     */
    public function getSubject()
    {
        return $this->subject;
    }


    /**
     * Set the subject (= unique identifier) of the end-user (= resource owner)
     * who allowed the authorization server  to issue the access token to the
     * client application.
     *
     * @param string $subject
     *     The subject of the end-user associated with the access token.
     *
     * @return IntrospectionAction
     *     `$this` object.
     */
    public function setSubject($subject)
    {
        ValidationUtility::ensureNullOrString('$subject', $subject);

        $this->subject = $subject;

        return $this;
    }


    /**
     * Get the scopes that are associated with the access token.
     *
     * @return string[]
     *     The scopes associated with the access token.
     */
    public function getScopes()
    {
        return $this->scopes;
    }


    /**
     * Set the scopes that are associated with the access token.
     *
     * @param string[] $scopes
     *     The scopes associated with the access token.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     */
    public function setScopes(array $scopes = null)
    {
        ValidationUtility::ensureNullOrArrayOfString('$scopes', $scopes);

        $this->scopes = $scopes;

        return $this;
    }


    /**
     * Get the flag which indicates whether the access token exists or not.
     *
     * @return boolean
     *     `true` if the access token exists.
     */
    public function isExistent()
    {
        return $this->existent;
    }


    /**
     * Set the flag which indicates whether the access token exists or not.
     *
     * @param boolean $existent
     *     `true` if the access token exists.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     */
    public function setExistent($existent)
    {
        ValidationUtility::ensureBoolean('$existent', $existent);

        $this->existent = $existent;

        return $this;
    }


    /**
     * Get the flag which indicates whether the access token is usable
     * (= exists and has not expired).
     *
     * @return boolean
     *     `true` if the access token is usable (= exists and has not expired).
     */
    public function isUsable()
    {
        return $this->usable;
    }


    /**
     * Set the flag which indicates whether the access token is usable
     * (= exists and has not expired).
     *
     * @param boolean $usable
     *     `true` if the access token is usable (= exists and has not expired).
     *
     * @return IntrospectionResponse
     *     `$this` object.
     */
    public function setUsable($usable)
    {
        ValidationUtility::ensureBoolean('$usable', $usable);

        $this->usable = $usable;

        return $this;
    }


    /**
     * Get the flag which indicates whether the access token covers the
     * required scopes.
     *
     * @return boolean
     *     `true` if the access token covers the required scopes.
     */
    public function isSufficient()
    {
        return $this->sufficient;
    }


    /**
     * Set the flag which indicates whether the access token covers the
     * required scopes.
     *
     * @param boolean $sufficient
     *     `true` if the access token covers the required scopes.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     */
    public function setSufficient($sufficient)
    {
        ValidationUtility::ensureBoolean('$sufficient', $sufficient);

        $this->sufficient = $sufficient;

        return $this;
    }


    /**
     * Get the flag which indicates whether the access token can be refreshed
     * using the associated refresh token.
     *
     * Even if there exists a refresh token associated with the access token,
     * this property returns `false` if the refresh token has already expired.
     *
     * @return boolean
     *     `true` if the access token can be refreshed using the associated
     *     refresh token.
     */
    public function isRefreshable()
    {
        return $this->refreshable;
    }


    /**
     * Set the flag which indicates whether the access token can be refreshed
     * using the associated refresh token.
     *
     * @param boolean $refreshable
     *     `true` if the access token can be refreshed using the associated
     *     refresh token.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     */
    public function setRefreshable($refreshable)
    {
        ValidationUtility::ensureBoolean('$refreshable', $refreshable);

        $this->refreshable = $refreshable;

        return $this;
    }


    /**
     * Get the response content which can be used as a part of the response
     * to the client application.
     *
     * @return string
     *     The response content.
     */
    public function getResponseContent()
    {
        return $this->responseContent;
    }


    /**
     * Set the response content which can be used as a part of the response
     * to the client application.
     *
     * @param string $responseContent
     *     The response content.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     */
    public function setResponseContent($responseContent)
    {
        ValidationUtility::ensureNullOrString('$responseContent', $responseContent);

        $this->responseContent = $responseContent;

        return $this;
    }


    /**
     * Get the time at which the access token will expire.
     *
     * @return integer|string
     *     The time at which the access token will expire. The value is
     *     represented as milliseconds since the Unix epoch (1970-Jan-1).
     */
    public function getExpiresAt()
    {
        return $this->expiresAt;
    }


    /**
     * Set the time at which the access token will expire.
     *
     * @param integer|string $expiresAt
     *     The time at which the access token will expire. The value should
     *     be represented as milliseconds since the Unix epoch (1970-Jan-1).
     */
    public function setExpiresAt($expiresAt)
    {
        ValidationUtility::ensureNullOrStringOrInteger('$expiresAt', $expiresAt);

        $this->expiresAt = $expiresAt;

        return $this;
    }


    /**
     * Get the properties associated with the access token.
     *
     * @return Property[]
     *     Properties.
     *
     * @since 1.3
     */
    public function getProperties()
    {
        return $this->properties;
    }


    /**
     * Set the properties associated with the access token.
     *
     * @param Property[] $properties
     *     Properties.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     *
     * @since 1.3
     */
    public function setProperties(array $properties = null)
    {
        ValidationUtility::ensureNullOrArrayOfType(
            '$properties', $properties, __NAMESPACE__ . '\Property');

        $this->properties = $properties;

        return $this;
    }


    /**
     * Get the client ID alias when the authorization request or the token
     * request for the access token was made.
     *
     * Note that this value may be different from the current client ID alias.
     *
     * @return string
     *     The client ID alias when the authorization request or the token
     *     request for the access token was made.
     *
     * @since 1.3
     */
    public function getClientIdAlias()
    {
        return $this->clientIdAlias;
    }


    /**
     * Set the client ID alias when the authorization request or the token
     * request for the access token was made.
     *
     * @param string $alias
     *     The client ID alias.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     *
     * @since 1.3
     */
    public function setClientIdAlias($alias)
    {
        ValidationUtility::ensureNullOrString('$alias', $alias);

        $this->clientIdAlias = $alias;

        return $this;
    }


    /**
     * Get the flag which indicates whether the client ID alias was used when
     * the authorization request or the token request for the access token
     * was made.
     *
     * @return boolean
     *     `true` if the client ID alias was used when the authorization
     *     request or the token request for the access token was made.
     *
     * @since 1.3
     */
    public function isClientIdAliasUsed()
    {
        return $this->clientIdAliasUsed;
    }


    /**
     * Set the flag which indicates whether the client ID alias was used when
     * the authorization request or the token request for the access token
     * was made.
     *
     * @param boolean $used
     *     `true` if the client ID alias was used when the authorization
     *     request or the token request for the access token was made.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     *
     * @since 1.3
     */
    public function setClientIdAliasUsed($used)
    {
        ValidationUtility::ensureBoolean('$used', $used);

        $this->clientIdAliasUsed = $used;

        return $this;
    }


    /**
     * Get the client certificate thumbprint used to validate the access token.
     *
     * @return string
     *     The certificate thumbprint, calculated as the SHA-256 hash of the
     *     DER-encoded certificate value.
     *
     * @since 1.3
     */
    public function getCertificateThumbprint()
    {
        return $this->certificateThumbprint;
    }


    /**
     * Set the client certificate thumbprint used to validate the access token.
     *
     * @param string $thumbprint
     *     The certificate thumbprint, calculated as the SHA-256 hash of the
     *     DER-encoded certificate value.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     *
     * @since 1.3
     */
    public function setCertificateThumbprint($thumbprint)
    {
        ValidationUtility::ensureNullOrString('$thumbprint', $thumbprint);

        $this->certificateThumbprint = $thumbprint;

        return $this;
    }


    /**
     * Get the target resources. This represents the resources specified by
     * the `resource` request parameters or by the `resource` property in
     * the request object.
     *
     * @return string[]
     *     The target resources.
     *
     * @see https://www.rfc-editor.org/rfc/rfc8707.html RFC 8707 Resource Indicators for OAuth 2.0
     *
     * @since 1.8
     */
    public function getResources()
    {
        return $this->resources;
    }


    /**
     * Set the target resources. This represents the resources specified by
     * the `resource` request parameters or by the `resource` property in
     * the request object.
     *
     * @param string[] $resources
     *     The target resources.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     *
     * @see https://www.rfc-editor.org/rfc/rfc8707.html RFC 8707 Resource Indicators for OAuth 2.0
     *
     * @since 1.8
     */
    public function setResources(array $resources = null)
    {
        ValidationUtility::ensureNullOrArrayOfString('$resources', $resources);

        $this->resources = $resources;

        return $this;
    }


    /**
     * Get the target resources of the access token.
     *
     * The target resources returned by this method may be the same as or
     * different from the ones returned by `getResources()` method.
     *
     * In some flows, the initial request and the subsequent token request
     * are sent to different endpoints. Example flows are the authorization
     * code flow, the refresh token flow, the CIBA ping mode, the CIBA poll
     * mode and the device flow. In these flows, not only the initial
     * request but also the subsequent token request can include the
     * `resource` request parameters. The purpose of the `resource` request
     * parameters in the token request is to narrow the range of the target
     * resources from the original set of target resources requested by the
     * preceding initial request. If narrowing down is performed, the target
     * resources returned by `getResources()` method and the ones returned
     * by this method are different. This method returns the narrowed set
     * of target resources.
     *
     * @return string[]
     *     The target resources of the access token.
     *
     * @see https://www.rfc-editor.org/rfc/rfc8707.html RFC 8707 Resource Indicators for OAuth 2.0
     *
     * @since 1.8
     */
    public function getAccessTokenResources()
    {
        return $this->accessTokenResources;
    }


    /**
     * Set the target resources of the access token.
     *
     * See the description of `getAccessTokenResources()` method for details
     * about the target resources of the access token.
     *
     * @param string[] $resources
     *     The target resources of the access token.
     *
     * @return IntrospectionResponse
     *     `$this` object.
     *
     * @see https://www.rfc-editor.org/rfc/rfc8707.html RFC 8707 Resource Indicators for OAuth 2.0
     *
     * @since 1.8
     */
    public function setAccessTokenResources(array $resources = null)
    {
        ValidationUtility::ensureNullOrArrayOfString('$resources', $resources);

        $this->accessTokenResources = $resources;

        return $this;
    }


    /**
     * Get the flag which indicates whether the access token is active
     * (= exists and has not expired).
     *
     * This method is just an alias of `isUsable()` method. The reason this
     * method was added is to mitigate confusion that those who are familiar
     * with [RFC 7662](https://tools.ietf.org/html/rfc7662) (OAuth 2.0 Token
     * Introspection) may have.
     *
     * @return boolean
     *     `true` if the access token is active (= exists and has not expired).
     */
    public function isActive()
    {
        return $this->isUsable();
    }


    /**
     * Set the flag which indicates whether the access token is active
     * (= exists and has not expired).
     *
     * This method is just an alias of `setUsable($usable)` method. The reason
     * this method was added is to mitigate confusion that those who are
     * familiar with [RFC 7662](https://tools.ietf.org/html/rfc7662) (OAuth 2.0
     * Token Introspection) may have.
     *
     * @param boolean $active
     *     `true` if the access token is active (= exists and has not expired).
     *
     * @return IntrospectionResponse
     *     `$this` object.
     */
    public function setActive($active)
    {
        ValidationUtility::ensureBoolean('$active', $active);

        return $this->setUsable($active);
    }


    /**
     * {@inheritdoc}
     *
     * {@inheritdoc}
     *
     * @param array $array
     *     {@inheritdoc}
     */
    public function copyToArray(array &$array)
    {
        parent::copyToArray($array);

        $array['action']                = LanguageUtility::toString($this->action);
        $array['clientId']              = $this->clientId;
        $array['subject']               = $this->subject;
        $array['scopes']                = $this->scopes;
        $array['existent']              = $this->existent;
        $array['usable']                = $this->usable;
        $array['sufficient']            = $this->sufficient;
        $array['refreshable']           = $this->refreshable;
        $array['responseContent']       = $this->responseContent;
        $array['expiresAt']             = $this->expiresAt;
        $array['properties']            = LanguageUtility::convertArrayOfArrayCopyableToArray($this->properties);
        $array['clientIdAlias']         = $this->clientIdAlias;
        $array['clientIdAliasUsed']     = $this->clientIdAliasUsed;
        $array['certificateThumbprint'] = $this->certificateThumbprint;
        $array['resources']             = $this->resources;
        $array['accessTokenResources']  = $this->accessTokenResources;
    }


    /**
     * {@inheritdoc}
     *
     * {@inheritdoc}
     *
     * @param array $array
     *     {@inheritdoc}
     */
    public function copyFromArray(array &$array)
    {
        parent::copyFromArray($array);

        // action
        $this->setAction(
            IntrospectionAction::valueOf(
                LanguageUtility::getFromArray('action', $array)));

        // clientId
        $this->setClientId(
            LanguageUtility::getFromArray('clientId', $array));

        // subject
        $this->setSubject(
            LanguageUtility::getFromArray('subject', $array));

        // scopes
        $this->setScopes(
            LanguageUtility::getFromArray('scopes', $array));

        // existent
        $this->setExistent(
            LanguageUtility::getFromArrayAsBoolean('existent', $array));

        // usable
        $this->setUsable(
            LanguageUtility::getFromArrayAsBoolean('usable', $array));

        // sufficient
        $this->setSufficient(
            LanguageUtility::getFromArrayAsBoolean('sufficient', $array));

        // refreshable
        $this->setRefreshable(
            LanguageUtility::getFromArrayAsBoolean('refreshable', $array));

        // responseContent
        $this->setResponseContent(
            LanguageUtility::getFromArray('responseContent', $array));

        // expiresAt
        $this->setExpiresAt(
            LanguageUtility::getFromArray('expiresAt', $array));

        // properties
        $properties = LanguageUtility::getFromArray('properties', $array);
        $this->setProperties(
            LanguageUtility::convertArrayToArrayOfArrayCopyable(
                $properties, __NAMESPACE__ . '\Property'));

        // clientIdAlias
        $this->setClientIdAlias(
            LanguageUtility::getFromArray('clientIdAlias', $array));

        // clientIdAliasUsed
        $this->setClientIdAliasUsed(
            LanguageUtility::getFromArrayAsBoolean('clientIdAliasUsed', $array));

        // certificateThumbprint
        $this->setCertificateThumbprint(
            LanguageUtility::getFromArray('certificateThumbprint', $array));

        // resources
        $this->setResources(
            LanguageUtility::getFromArray('resources', $array));

        // accessTokenResources
        $this->setAccessTokenResources(
            LanguageUtility::getFromArray('accessTokenResources', $array));
    }
}
?>

